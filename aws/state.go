package aws

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
)

type state struct {
	Real awsResourceMap
	Cfn  extResourceMap
	Tf   extResourceMap
}

func (state state) writeToDisk() (err error) {
	file, err := json.MarshalIndent(state, "", " ")
	if err != nil {
		return
	}
	err = ioutil.WriteFile("aws-resource-list.json", file, 0644)
	return
}

func (state state) readFromDisk() (err error) {
	jsonFile, err := os.Open("aws-resource-list.json")
	if err != nil {
		return
	}
	defer jsonFile.Close()
	byteValue, err := ioutil.ReadAll(jsonFile)
	if err != nil {
		return
	}
	err = json.Unmarshal(byteValue, &state)
	return
}

type awsResourceMap map[resourceType][]string

func (awsResourceMap awsResourceMap) print() {
	for key, valueList := range awsResourceMap {
		fmt.Println(" -", key)
		for _, value := range valueList {
			fmt.Println("     -", value)
		}
	}
}

func reduce(maps ...awsResourceMap) (result awsResourceMap) {
	result = awsResourceMap{}
	for _, m := range maps {
		for key, value := range m {
			result[key] = value
		}
	}
	return
}

type extResourceMap map[string][]string

func (extResourceMap extResourceMap) print() {
	for key, valueList := range extResourceMap {
		fmt.Println(" -", key)
		for _, value := range valueList {
			fmt.Println("     -", value)
		}
	}
}

// Return all resources that where not generated by cloudformation of terraform
func (state state) filter() (r awsResourceMap) {
	r = state.Real
	for cfnType, cfnResourceIDs := range state.Cfn {
		awsResourceType, _ := fromCloudFormationType(cfnType)
		for _, cfnResourceID := range cfnResourceIDs {
			if contains(r[awsResourceType], cfnResourceID) {
				r[awsResourceType] = deleteFromStringSlice(r[awsResourceType], cfnResourceID)
			}
		}
	}
	for tfType, tfResourceIDs := range state.Tf {
		awsResourceType, _ := fromTerraformType(tfType)
		for _, tfResourceID := range tfResourceIDs {
			if contains(r[awsResourceType], tfResourceID) {
				r[awsResourceType] = deleteFromStringSlice(r[awsResourceType], tfResourceID)
			}
		}
	}
	for resourceType, resourceIDs := range r {
		if len(resourceIDs) == 0 {
			delete(r, resourceType)
		}
	}
	return
}

// Test if a string is in a slice of strings
func contains(arr []string, str string) bool {
	for _, a := range arr {
		if a == str {
			return true
		}
	}
	return false
}

func deleteFromStringSlice(slice []string, s string) []string {
	for i, item := range slice {
		if item == s {
			slice = append(slice[:i], slice[i+1:]...)
			slice = deleteFromStringSlice(slice, s)
			return slice
		}
	}
	return slice
}
